// =============================================================
// ReunIA — Face Match Pipeline
// Orchestrates: detect → embed → search → rank → enqueue HITL
//
// Sprint 4 (FS-01): Dual-engine support
// 1. Primary: Python ArcFace service (512-dim, production-grade)
// 2. Fallback: JS-native feature engine (512-dim, MVP-grade)
//
// The pipeline automatically falls back to JS engine when the
// Python service is unavailable, enabling face search E2E
// without requiring GPU or Python deployment.
// =============================================================

import { faceClient } from './face-client'
import {
  searchSimilarFaces,
  searchSimilarFacesPrecise,
  getConfidenceTier,
  SIMILARITY_THRESHOLDS,
  type SimilarFaceResult,
  type ConfidenceTier,
} from './embedding-store'
import {
  jsDetectFace,
  jsGenerateEmbedding,
  cosineSimilarity,
  isPythonServiceAvailable,
} from './js-face-engine'
import { logger } from '@/lib/logger'
import { db } from '@/lib/db'
import { writeAuditLog } from '@/lib/audit'
import { env } from '@/lib/env'

// ---------------------------------------------------------------
// Types
// ---------------------------------------------------------------

export interface FaceMatchInput {
  imageBase64: string
  querySource: 'citizen_upload' | 'sighting_photo' | 'le_batch' | 'operator_manual'
  requestedById?: string
  sightingId?: string
  /** Minimum similarity threshold — defaults to LOW (0.55) */
  threshold?: number
  /** Max results to return */
  maxResults?: number
  /** Use precise search (HITL validation mode — slower but higher recall) */
  precise?: boolean
}

export interface RankedMatch {
  faceEmbeddingId: string
  personId: string
  caseId: string
  similarity: number
  confidenceTier: ConfidenceTier
  /** Person's display name */
  personName: string | null
  /** Case number */
  caseNumber: string
  /** Primary photo URL for display */
  primaryPhotoUrl: string | null
}

export interface FaceMatchPipelineResult {
  success: boolean
  queryEmbeddingId?: string
  matches: RankedMatch[]
  matchCount: number
  faceDetected: boolean
  faceConfidence: number | null
  faceQuality: number | null
  processingMs: number
  /** Match IDs enqueued for HITL review */
  enqueuedMatchIds: string[]
  /** Which engine was used: 'arcface' (Python) or 'js-native' */
  engine?: string
  error?: string
}

// ---------------------------------------------------------------
// Cache Python service availability (check once per 60s)
// ---------------------------------------------------------------

let pythonServiceAvailable: boolean | null = null
let lastServiceCheck = 0
const SERVICE_CHECK_TTL_MS = 60_000 // Re-check every 60 seconds

async function checkPythonService(): Promise<boolean> {
  const now = Date.now()
  if (pythonServiceAvailable !== null && now - lastServiceCheck < SERVICE_CHECK_TTL_MS) {
    return pythonServiceAvailable
  }

  pythonServiceAvailable = await isPythonServiceAvailable(env.FACE_ENGINE_URL)
  lastServiceCheck = now

  logger.info(
    { available: pythonServiceAvailable, url: env.FACE_ENGINE_URL },
    'FaceMatchPipeline: Python service availability check'
  )

  return pythonServiceAvailable
}

// ---------------------------------------------------------------
// JS Fallback: Brute-force cosine similarity search
// Used when pgvector functions are not available or embeddings
// were generated by JS engine (not ArcFace)
// ---------------------------------------------------------------

async function searchSimilarFacesJS(
  queryEmbedding: number[],
  threshold: number,
  maxResults: number
): Promise<SimilarFaceResult[]> {
  // Load all searchable embeddings from the database
  const embeddings = await db.faceEmbedding.findMany({
    where: {
      isSearchable: true,
      embedding: { not: null },
    },
    select: {
      id: true,
      personId: true,
      embedding: true,
      person: {
        select: {
          caseId: true,
        },
      },
    },
  })

  if (embeddings.length === 0) {
    logger.info('FaceMatchPipeline/JS: no embeddings in database')
    return []
  }

  logger.info(
    { embeddingCount: embeddings.length },
    'FaceMatchPipeline/JS: loaded embeddings for brute-force search'
  )

  // Compute cosine similarity for each embedding
  const results: Array<SimilarFaceResult & { rawSimilarity: number }> = []

  for (const stored of embeddings) {
    if (!stored.embedding) continue

    try {
      // Decode the stored embedding from Bytes (Buffer)
      // The embedding is stored as a Float32Array buffer or as a pgvector string
      let storedVector: number[]

      if (Buffer.isBuffer(stored.embedding)) {
        // Stored as Float32Array bytes
        const float32 = new Float32Array(
          stored.embedding.buffer,
          stored.embedding.byteOffset,
          stored.embedding.byteLength / 4
        )
        storedVector = Array.from(float32)
      } else {
        // Should not happen with Prisma Bytes type, but handle gracefully
        continue
      }

      // Skip if dimensions don't match
      if (storedVector.length !== queryEmbedding.length) {
        continue
      }

      const similarity = cosineSimilarity(queryEmbedding, storedVector)

      if (similarity >= threshold) {
        results.push({
          faceId: stored.id,
          personId: stored.personId,
          caseId: stored.person.caseId,
          similarity,
          rawSimilarity: similarity,
        })
      }
    } catch (err) {
      // Skip this embedding — malformed data
      logger.debug(
        { embeddingId: stored.id, err },
        'FaceMatchPipeline/JS: failed to process stored embedding'
      )
    }
  }

  // Sort by similarity descending, take top N
  results.sort((a, b) => b.similarity - a.similarity)
  return results.slice(0, maxResults).map(({ rawSimilarity: _, ...rest }) => rest)
}

// ---------------------------------------------------------------
// Main pipeline
// ---------------------------------------------------------------

/**
 * Full face match pipeline.
 *
 * Steps:
 * 1. Check Python service availability → select engine
 * 2. Detect face in uploaded image
 * 3. Generate embedding (ArcFace or JS-native)
 * 4. Search for similar embeddings (pgvector or JS brute-force)
 * 5. Enrich results with person/case metadata
 * 6. Create Match records + enqueue for HITL review (NON-NEGOTIABLE)
 * 7. Return ranked match list (WITHOUT exposing raw biometric data)
 */
export async function runFaceMatchPipeline(
  input: FaceMatchInput
): Promise<FaceMatchPipelineResult> {
  const pipelineStart = Date.now()
  const {
    imageBase64,
    querySource,
    requestedById,
    sightingId,
    threshold = SIMILARITY_THRESHOLDS.REJECT,
    maxResults = 20,
    precise = false,
  } = input

  logger.info(
    { querySource, requestedById, threshold, maxResults },
    'FaceMatchPipeline: starting'
  )

  // ---------------------------------------------------------------
  // Step 1: Engine selection
  // ---------------------------------------------------------------
  const usePython = await checkPythonService()
  const engineName = usePython ? 'arcface' : 'js-native'

  logger.info({ engine: engineName }, 'FaceMatchPipeline: engine selected')

  // ---------------------------------------------------------------
  // Step 2+3: Detect face and generate embedding
  // ---------------------------------------------------------------
  let faceDetected = false
  let faceConfidence: number | null = null
  let faceQuality: number | null = null
  let embedding: number[] | null = null

  if (usePython) {
    // -- Python ArcFace path --
    try {
      const detectResult = await faceClient.detect(imageBase64)

      if (detectResult.face_count === 0) {
        logger.warn({ querySource }, 'FaceMatchPipeline: no face detected (ArcFace)')
        return {
          success: false,
          matches: [],
          matchCount: 0,
          faceDetected: false,
          faceConfidence: null,
          faceQuality: null,
          processingMs: Date.now() - pipelineStart,
          enqueuedMatchIds: [],
          engine: engineName,
          error: 'No face detected in the uploaded image',
        }
      }

      faceDetected = true
      const primaryFace = detectResult.faces[0]!
      const embedResult = await faceClient.embed(imageBase64, primaryFace.bounding_box)
      embedding = embedResult.embedding
      faceConfidence = embedResult.face_confidence
      faceQuality = embedResult.face_quality
    } catch (err) {
      logger.error({ err, querySource }, 'FaceMatchPipeline: ArcFace failed, falling back to JS engine')
      // Fall through to JS engine
    }
  }

  // -- JS-native fallback path --
  if (!embedding) {
    try {
      const detectResult = await jsDetectFace(imageBase64)

      if (!detectResult.faceDetected) {
        logger.warn({ querySource }, 'FaceMatchPipeline: image validation failed (JS)')
        return {
          success: false,
          matches: [],
          matchCount: 0,
          faceDetected: false,
          faceConfidence: null,
          faceQuality: null,
          processingMs: Date.now() - pipelineStart,
          enqueuedMatchIds: [],
          engine: 'js-native',
          error: 'No face detected in the uploaded image',
        }
      }

      faceDetected = true
      const embedResult = await jsGenerateEmbedding(imageBase64)
      embedding = embedResult.embedding
      faceConfidence = embedResult.faceConfidence
      faceQuality = embedResult.faceQuality
    } catch (err) {
      logger.error({ err, querySource }, 'FaceMatchPipeline: JS engine also failed')
      return {
        success: false,
        matches: [],
        matchCount: 0,
        faceDetected,
        faceConfidence,
        faceQuality: null,
        processingMs: Date.now() - pipelineStart,
        enqueuedMatchIds: [],
        engine: 'js-native',
        error: err instanceof Error ? err.message : 'Face processing failed',
      }
    }
  }

  logger.info(
    {
      querySource,
      engine: embedding ? engineName : 'js-native',
      faceConfidence,
      faceQuality,
      embeddingDims: embedding.length,
    },
    'FaceMatchPipeline: embedding generated'
  )

  // ---------------------------------------------------------------
  // Step 4: Search for similar faces
  // Try pgvector first, fall back to JS brute-force
  // ---------------------------------------------------------------
  let similarFaces: SimilarFaceResult[] = []
  let searchMethod = 'pgvector'

  try {
    similarFaces = precise
      ? await searchSimilarFacesPrecise(embedding, threshold, maxResults)
      : await searchSimilarFaces(embedding, threshold, maxResults)

    logger.info(
      { querySource, candidateCount: similarFaces.length, method: 'pgvector' },
      'FaceMatchPipeline: similarity search complete'
    )
  } catch (pgvectorErr) {
    // pgvector search failed (function may not exist, or vector type mismatch)
    // Fall back to JS brute-force search
    logger.warn(
      { err: pgvectorErr, querySource },
      'FaceMatchPipeline: pgvector search failed, falling back to JS brute-force'
    )

    try {
      similarFaces = await searchSimilarFacesJS(embedding, threshold, maxResults)
      searchMethod = 'js-brute-force'

      logger.info(
        { querySource, candidateCount: similarFaces.length, method: 'js-brute-force' },
        'FaceMatchPipeline: JS brute-force search complete'
      )
    } catch (jsErr) {
      logger.error({ err: jsErr, querySource }, 'FaceMatchPipeline: all search methods failed')
      return {
        success: false,
        matches: [],
        matchCount: 0,
        faceDetected,
        faceConfidence,
        faceQuality,
        processingMs: Date.now() - pipelineStart,
        enqueuedMatchIds: [],
        engine: engineName,
        error: 'Database search failed',
      }
    }
  }

  // ---------------------------------------------------------------
  // Step 5: Enrich matches with person/case metadata
  // ---------------------------------------------------------------
  const enrichedMatches: RankedMatch[] = []
  const matchRecordIds: string[] = []

  for (const candidate of similarFaces) {
    try {
      const person = await db.person.findUnique({
        where: { id: candidate.personId },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          case: { select: { id: true, caseNumber: true } },
          images: {
            where: { isPrimary: true },
            select: { thumbnailUrl: true, storageUrl: true },
            take: 1,
          },
        },
      })

      if (!person) {
        logger.warn({ personId: candidate.personId }, 'FaceMatchPipeline: person not found, skipping')
        continue
      }

      const confidenceTier = getConfidenceTier(candidate.similarity)

      // ---------------------------------------------------------------
      // Step 6: Create Match record in DB (every match goes through HITL)
      // NON-NEGOTIABLE: families are NEVER notified without human review
      // ---------------------------------------------------------------
      const matchRecord = await db.match.create({
        data: {
          querySource: querySource as 'citizen_upload',
          matchedEmbeddingId: candidate.faceId,
          matchedPersonId: candidate.personId,
          matchedCaseId: candidate.caseId,
          similarityScore: candidate.similarity,
          thresholdUsed: threshold,
          confidenceTier: mapConfidenceTierToPrisma(confidenceTier),
          reviewStatus: 'pending',
          requestedById: requestedById ?? null,
          sightingId: sightingId ?? null,
          requestedAt: new Date(),
        },
      })

      matchRecordIds.push(matchRecord.id)

      enrichedMatches.push({
        faceEmbeddingId: candidate.faceId,
        personId: candidate.personId,
        caseId: candidate.caseId,
        similarity: candidate.similarity,
        confidenceTier,
        personName:
          [person.firstName, person.lastName].filter(Boolean).join(' ') || null,
        caseNumber: person.case.caseNumber,
        primaryPhotoUrl:
          person.images[0]?.thumbnailUrl ?? person.images[0]?.storageUrl ?? null,
      })
    } catch (err) {
      logger.warn({ err, candidatePersonId: candidate.personId }, 'FaceMatchPipeline: enrichment failed for candidate')
    }
  }

  // ---------------------------------------------------------------
  // Step 7: Enqueue matches for HITL review
  // ---------------------------------------------------------------
  const enqueuedMatchIds: string[] = []

  for (const matchId of matchRecordIds) {
    try {
      await enqueuHitl(matchId, enrichedMatches)
      enqueuedMatchIds.push(matchId)
    } catch (err) {
      logger.warn({ err, matchId }, 'FaceMatchPipeline: failed to enqueue match for HITL')
    }
  }

  // ---------------------------------------------------------------
  // Audit log
  // ---------------------------------------------------------------
  writeAuditLog({
    userId: requestedById,
    action: 'face_match.submit',
    resourceType: 'match',
    details: {
      querySource,
      engine: engineName,
      searchMethod,
      candidateCount: similarFaces.length,
      enqueuedCount: enqueuedMatchIds.length,
      faceConfidence,
      faceQuality,
    },
  })

  const totalMs = Date.now() - pipelineStart

  logger.info(
    {
      querySource,
      engine: engineName,
      searchMethod,
      matchCount: enrichedMatches.length,
      enqueuedCount: enqueuedMatchIds.length,
      totalMs,
    },
    'FaceMatchPipeline: complete'
  )

  return {
    success: true,
    matches: enrichedMatches,
    matchCount: enrichedMatches.length,
    faceDetected: true,
    faceConfidence,
    faceQuality,
    processingMs: totalMs,
    enqueuedMatchIds,
    engine: engineName,
  }
}

// ---------------------------------------------------------------
// HITL Enqueue helper — graceful when Redis is unavailable
// ---------------------------------------------------------------

async function enqueuHitl(
  matchId: string,
  enrichedMatches: RankedMatch[]
): Promise<void> {
  // Dynamically import to avoid Redis connection errors at module load
  try {
    const { validationQueue } = await import('./validation-queue')
    await validationQueue.enqueue({
      matchId,
      priority: determinePriority(
        enrichedMatches.find((m) => m.faceEmbeddingId)?.confidenceTier ?? 'LOW'
      ),
    })
  } catch (err) {
    // If Redis is down, log but don't fail the pipeline
    // The match record is already in the database with review_status=pending
    logger.warn(
      { err, matchId },
      'FaceMatchPipeline: HITL queue unavailable, match saved to DB with pending status'
    )
  }
}

// ---------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------

function mapConfidenceTierToPrisma(
  tier: ConfidenceTier
): 'possible' | 'likely' | 'confident' | 'very_confident' {
  switch (tier) {
    case 'HIGH':
      return 'very_confident'
    case 'MEDIUM':
      return 'confident'
    case 'LOW':
      return 'likely'
    default:
      return 'possible'
  }
}

function determinePriority(tier: ConfidenceTier): 'high' | 'normal' | 'low' {
  switch (tier) {
    case 'HIGH':
      return 'high'
    case 'MEDIUM':
      return 'normal'
    default:
      return 'low'
  }
}
